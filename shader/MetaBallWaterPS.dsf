f//STAGE:ps
#include "Common.dsh"
#include "CalcSDF.dsh"
#include "shared/LiquidGlass.h"
#include "CalcSDF.dsh"

struct MetaballData
{
    float3 position;
    float radius;
    float intensity;
};

struct MetaBallWaterParam
{
	uint metaballCount;
    float surfaceThreshold;
    float blendSmoothness;
    float refractionStrength;
};

cbuffer CameraConstants
{
    float4x4 viewProjection;
    float3 cameraPosition;
    float time;
};

cbuffer cb_MetaBallWaterParam
{
	LiquidGlassParam param;
}

StructuredBuffer<MetaballData> metaballs : register(t0);

// 单个 Metaball 场函数
float MetaballField(float3 pos, MetaballData ball)
{
    float3 toCenter = pos - ball.position;
    float sqrDist = dot(toCenter, toCenter);
    
    // 避免除零，使用平滑的场函数
    return (ball.radius * ball.radius) / (sqrDist + 0.0001) * ball.intensity;
}

// 计算所有 Metaball 的总场
float CalculateTotalField(float3 pos)
{
    float totalField = 0.0;
    
    for (uint i = 0; i < metaballCount; i++)
    {
        totalField += MetaballField(pos, metaballs[i]);
    }
    
    return totalField;
}

// 将场函数转换为有符号距离场
float SceneSDF(float3 pos)
{
    float field = CalculateTotalField(pos);
    return surfaceThreshold - field;
}

// 计算法线（通过有限差分）
float3 CalculateNormal(float3 pos)
{
    const float2 eps = float2(0.001, 0.0);
    
    float3 normal;
    normal.x = SceneSDF(pos + eps.xyy) - SceneSDF(pos - eps.xyy);
    normal.y = SceneSDF(pos + eps.yxy) - SceneSDF(pos - eps.yxy);
    normal.z = SceneSDF(pos + eps.yyx) - SceneSDF(pos - eps.yyx);
    
    return normalize(normal);
}

// 水滴颜色计算
float4 CalculateWaterColor(float3 pos, float3 normal, float3 viewDir)
{
    // 基础颜色 - 水的颜色
    float3 baseColor = float3(0.3, 0.6, 1.0);
    
    // 根据场强度调整颜色深度
    float fieldStrength = CalculateTotalField(pos);
    float depthFactor = smoothstep(surfaceThreshold - blendSmoothness, 
                                  surfaceThreshold + blendSmoothness, 
                                  fieldStrength);
    
    // 融合区域颜色更深
    baseColor *= lerp(0.8, 1.3, depthFactor);
    
    // 光照计算
    float3 lightDir = normalize(float3(1, 2, 1));
    float diffuse = max(0, dot(normal, lightDir));
    
    // 高光反射
    float3 reflectDir = reflect(-lightDir, normal);
    float specular = pow(max(0, dot(reflectDir, viewDir)), 64.0) * 0.5;
    
    // 菲涅尔效应
    float fresnel = pow(1.0 - max(0, dot(normal, viewDir)), 3.0);
    
    // 最终颜色合成
    float3 finalColor = baseColor * (diffuse + 0.3) + specular;
    float alpha = 0.9 * (1.0 - fresnel * 0.5);
    
    return float4(finalColor, alpha);
}

// 主光线步进函数
float4 RaymarchMetaballs(float3 rayOrigin, float3 rayDir)
{
    const int MAX_STEPS = 100;
    const float MAX_DIST = 20.0;
    const float SURFACE_DIST = 0.001;
    
    float t = 0.0;
    float3 pos = rayOrigin;
    
    for (int i = 0; i < MAX_STEPS; i++)
    {
        pos = rayOrigin + rayDir * t;
        float dist = SceneSDF(pos);
        
        if (dist < SURFACE_DIST)
        {
            // 命中表面，计算法线和颜色
            float3 normal = CalculateNormal(pos);
            float3 viewDir = -rayDir;
            return CalculateWaterColor(pos, normal, viewDir);
        }
        
        if (t > MAX_DIST)
            break;
            
        t += dist * 0.8; // 加速步进
    }
    
    // 未命中，返回透明
    return float4(0, 0, 0, 0);
}

// 主像素着色器
float4 main(VertexOutput input) : SV_Target
{
    float3 rayOrigin = cameraPosition;
    float3 rayDir = normalize(input.worldPos - cameraPosition);
    
    // 应用简单的折射效果
    rayDir.xz += sin(input.worldPos.xz * 10.0 + time) * refractionStrength * 0.1;
    
    return RaymarchMetaballs(rayOrigin, rayDir);
}
